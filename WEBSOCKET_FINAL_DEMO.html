<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juno WebSocket | Real-Time Native</title>
    <style>
        /* BRUTALIST CSS RESET */
        * { box-sizing: border-box; outline: none; }
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background-color: #f0f0f0;
            color: #000;
            min-height: 100vh;
        }

        /* LAYOUT */
        .container {
            max-width: 1000px;
            margin: 0 auto;
            border: 4px solid #000;
            background: #fff;
            box-shadow: 10px 10px 0px #000;
        }

        /* HEADER */
        header {
            border-bottom: 4px solid #000;
            padding: 20px;
            background: #000;
            color: #fff;
        }
        h1 {
            margin: 0;
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: -2px;
        }
        .subtitle {
            font-size: 1rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* GRID */
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 4px solid #000;
        }
        @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } }

        .panel {
            padding: 20px;
            border-right: 4px solid #000;
        }
        .panel:last-child { border-right: none; }

        h2 {
            margin-top: 0;
            text-transform: uppercase;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        /* CONTROLS */
        .control-group { margin-bottom: 15px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #000;
            font-family: inherit;
            font-size: 1rem;
            background: #fff;
        }
        input:focus { background: #ffff00; }

        button {
            width: 100%;
            padding: 15px;
            background: #000;
            color: #fff;
            border: none;
            font-family: inherit;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover { background: #333; }
        button:active { transform: translateY(2px); }
        button.secondary { background: #fff; color: #000; border: 2px solid #000; }
        button.secondary:hover { background: #eee; }

        /* LOGS */
        #logs {
            height: 300px;
            overflow-y: auto;
            padding: 20px;
            background: #000;
            color: #00ff00;
            font-size: 0.9rem;
            border-top: 4px solid #000;
        }
        .log-entry { margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .log-time { color: #888; margin-right: 10px; }
        .log-type-error { color: #ff0000; }
        .log-type-success { color: #ffff00; }

        /* STATUS INDICATOR */
        .status-badge {
            display: inline-block;
            padding: 5px 10px;
            background: #ff0000;
            color: #fff;
            font-weight: bold;
            border: 2px solid #fff;
        }
        .status-badge.connected { background: #00ff00; color: #000; }

        /* ANIMATIONS */
        @keyframes flash {
            0% { background-color: #ffff00; }
            100% { background-color: #fff; }
        }
        .flash { animation: flash 1s; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1>Juno WebSocket</h1>
                <div class="subtitle">NATIVE IC WEBSOCKET IMPLEMENTATION</div>
            </div>
            <div id="connectionStatus" class="status-badge">DISCONNECTED</div>
        </div>
    </header>

    <div class="grid">
        <!-- LEFT PANEL: CONFIG & ACTIONS -->
        <div class="panel">
            <h2>Configuration</h2>
            <div class="control-group">
                <label>Canister ID</label>
                <input type="text" id="canisterId" value="uzt4z-lp777-77774-qaabq-cai">
            </div>
            <div class="control-group">
                <label>Gateway URL</label>
                <input type="text" id="gatewayUrl" value="ws://127.0.0.1:8081">
            </div>
            <div class="control-group">
                <button onclick="window.app.toggleConnection()" id="btnConnect">CONNECT TO WEBSOCKET</button>
            </div>

            <h2 style="margin-top: 30px;">Trigger Event</h2>
            <p style="font-size: 0.8rem; margin-bottom: 15px;">
                Note: Creating a document triggers a `doc_set` notification to all subscribers.
            </p>
            <div class="control-group">
                <label>Collection</label>
                <input type="text" id="collection" value="demo_chat">
            </div>
            <div class="control-group">
                <label>Message</label>
                <input type="text" id="messageData" value="Hello from WebSocket!">
            </div>
            <div class="control-group">
                <button class="secondary" onclick="window.app.createDoc()">üìù Create Document</button>
            </div>
        </div>

        <!-- RIGHT PANEL: NOTIFICATIONS -->
        <div class="panel" style="background: #ffff0033;">
            <h2>Live Feed</h2>
            <div id="notifications" style="height: 400px; overflow-y: auto;">
                <div style="text-align: center; opacity: 0.5; margin-top: 50px;">
                    Waiting for events...
                </div>
            </div>
        </div>
    </div>

    <!-- SYSTEM LOGS -->
    <div id="logs">
        <div class="log-entry">System initialized. Ready to connect.</div>
    </div>
</div>

<script type="module">
/**
 * JUNO WEBSOCKET SDK (Embedded for Demo)
 */
class JunoWebSocket {
  constructor(config) {
    this.config = {
      gatewayUrl: config.gatewayUrl || 'wss://ws.omnia-network.ic0.app',
      canisterId: config.canisterId,
      reconnectInterval: config.reconnectInterval || 5000,
      heartbeatInterval: config.heartbeatInterval || 30000,
      autoConnect: config.autoConnect !== false,
    };
    this.ws = null;
    this.isConnected = false;
    this.subscriptions = new Map();
    this.clientKey = `client_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
    this.heartbeatTimer = null;
    this.reconnectTimer = null;

    if (this.config.autoConnect) this.connect();
  }

  connect() {
    if (this.ws?.readyState === WebSocket.OPEN) return;
    
    window.app.log(`Connecting to ${this.config.gatewayUrl}...`, 'info');

    try {
      this.ws = new WebSocket(this.config.gatewayUrl);
      this.ws.binaryType = 'arraybuffer';
      this.ws.onopen = () => this.handleOpen();
      this.ws.onmessage = (event) => this.handleMessage(event.data);
      this.ws.onclose = () => this.handleClose();
      this.ws.onerror = (error) => this.handleError(error);
    } catch (error) {
      window.app.log(`Connection failed: ${error.message}`, 'error');
      this.scheduleReconnect();
    }
  }

  disconnect() {
    this.clearHeartbeat();
    this.clearReconnect();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isConnected = false;
    window.app.updateStatus(false);
  }

  subscribe(collection, callback) {
    if (!this.subscriptions.has(collection)) {
      this.subscriptions.set(collection, new Set());
    }
    this.subscriptions.get(collection).add(callback);
    this.sendSubscribe([collection]);
    return () => this.unsubscribe(collection, callback);
  }

  unsubscribe(collection, callback) {
    const callbacks = this.subscriptions.get(collection);
    if (callbacks) {
      callbacks.delete(callback);
      if (callbacks.size === 0) {
        this.subscriptions.delete(collection);
        this.sendUnsubscribe([collection]);
      }
    }
  }

  // PRIVATE METHODS
  handleOpen() {
    window.app.log('WebSocket Connected!', 'success');
    this.isConnected = true;
    window.app.updateStatus(true);
    this.clearReconnect();

    // Handshake
    this.sendMessage({
      type: 'open',
      clientKey: this.clientKey,
      canisterId: this.config.canisterId,
    });

    this.startHeartbeat();

    // Resubscribe
    const collections = Array.from(this.subscriptions.keys());
    if (collections.length > 0) this.sendSubscribe(collections);
  }

  async handleMessage(data) {
    try {
      // Debug log to see what we are receiving
      // console.log('WebSocket received:', typeof data, data);

      let message;
      if (typeof data === 'string') {
        message = JSON.parse(data);
      } else if (data instanceof Blob) {
        const text = await data.text();
        message = JSON.parse(text);
      } else if (data instanceof ArrayBuffer) {
        const text = new TextDecoder().decode(data);
        console.log('Decoded text:', text); // DEBUG
        // Check if it's a known non-JSON message
        if (text.includes("gateway")) {
             console.log("Received gateway message:", text);
             return; // Skip JSON parsing for now
        }
        message = JSON.parse(text);
      } else {
        // Fallback for unexpected types
        console.warn('Unknown data type:', data);
        window.app.log(`Unknown data type: ${typeof data}`, 'error');
        return;
      }
      
      // Process the message
      switch (message.type) {
        case 'welcome': window.app.log('Server welcomed us.', 'info'); break;
        case 'pong': break; // Heartbeat
        case 'doc_set':
        case 'doc_deleted':
          this.notifySubscribers(message);
          break;
        case 'error':
          window.app.log(`Server Error: ${message.payload?.error}`, 'error');
          break;
      }
    } catch (error) {
      console.error('Parse error', error);
      window.app.log(`Message processing error: ${error.message}`, 'error');
    }
  }

  notifySubscribers(notification) {
    const callbacks = this.subscriptions.get(notification.collection);
    if (callbacks) {
      callbacks.forEach(cb => cb(notification));
    }
  }

  handleClose() {
    window.app.log('WebSocket Disconnected', 'error');
    this.isConnected = false;
    window.app.updateStatus(false);
    this.clearHeartbeat();
    this.scheduleReconnect();
  }

  handleError(error) {
    window.app.log('WebSocket Error', 'error');
  }

  sendMessage(message) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }

  sendSubscribe(collections) {
    this.sendMessage({ command: 'subscribe', collections });
    window.app.log(`Subscribed to: ${collections.join(', ')}`, 'info');
  }

  startHeartbeat() {
    this.clearHeartbeat();
    this.heartbeatTimer = setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) this.sendMessage({ command: 'ping' });
    }, this.config.heartbeatInterval);
  }

  clearHeartbeat() {
    if (this.heartbeatTimer) clearInterval(this.heartbeatTimer);
  }

  scheduleReconnect() {
    this.clearReconnect();
    this.reconnectTimer = setTimeout(() => {
        window.app.log('Reconnecting...', 'info');
        this.connect();
    }, this.config.reconnectInterval);
  }

  clearReconnect() {
    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
  }
}

/**
 * APPLICATION LOGIC
 */
class DemoApp {
    constructor() {
        this.ws = null;
    }

    log(msg, type = 'normal') {
        const logs = document.getElementById('logs');
        const entry = document.createElement('div');
        entry.className = `log-entry log-type-${type}`;
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<span class="log-time">[${time}]</span> ${msg}`;
        logs.insertBefore(entry, logs.firstChild);
    }

    updateStatus(connected) {
        const el = document.getElementById('connectionStatus');
        const btn = document.getElementById('btnConnect');
        if (connected) {
            el.textContent = 'CONNECTED';
            el.classList.add('connected');
            btn.textContent = 'DISCONNECT';
            btn.style.background = '#00ff00';
            btn.style.color = '#000';
        } else {
            el.textContent = 'DISCONNECTED';
            el.classList.remove('connected');
            btn.textContent = 'CONNECT TO WEBSOCKET';
            btn.style.background = '#000';
            btn.style.color = '#fff';
        }
    }

    toggleConnection() {
        if (this.ws && this.ws.isConnected) {
            this.ws.disconnect();
            this.ws = null;
        } else {
            const canisterId = document.getElementById('canisterId').value;
            const gatewayUrl = document.getElementById('gatewayUrl').value;
            
            this.ws = new JunoWebSocket({
                canisterId,
                gatewayUrl,
                autoConnect: true
            });

            // Auto subscribe to the collection input
            const collection = document.getElementById('collection').value;
            this.ws.subscribe(collection, (notif) => {
                this.renderNotification(notif);
            });
        }
    }

    renderNotification(notif) {
        const container = document.getElementById('notifications');
        const el = document.createElement('div');
        el.style.border = '2px solid #000';
        el.style.padding = '10px';
        el.style.marginBottom = '10px';
        el.style.background = '#fff';
        el.className = 'flash';
        
        el.innerHTML = `
            <strong>${notif.type.toUpperCase()}</strong>
            <br>Collection: ${notif.collection}
            <br>Key: ${notif.key}
            <br><small>${new Date().toLocaleTimeString()}</small>
        `;
        
        container.insertBefore(el, container.firstChild);
        this.log(`Received notification: ${notif.type} on ${notif.key}`, 'success');
    }

    async createDoc() {
        // This is a simulation or needs to call the actual canister HTTP endpoint if possible
        // Since we can't easily import the full Juno SDK here, we'll try a raw fetch if the canister supports it
        // OR we just rely on the user knowing they need to trigger it elsewhere.
        // But for a demo, let's try to be helpful.
        
        const canisterId = document.getElementById('canisterId').value;
        const collection = document.getElementById('collection').value;
        const msg = document.getElementById('messageData').value;
        
        // IMPORTANT: In a real app, this would use the Juno SDK to write.
        // Since this is a standalone HTML demo without build step, we can't easily sign messages.
        // However, if the canister allows anonymous writes (which the PUNK demo suggested), we might be able to.
        
        this.log('‚ö†Ô∏è To trigger a real WebSocket event, the canister state must change.', 'info');
        this.log('‚ö†Ô∏è In a full app, you would use `juno.setDoc()` here.', 'info');
        this.log('‚ö†Ô∏è For this demo, please use the PUNK_REALTIME.html to write data, and watch it appear here!', 'info');
        
        // Simulating a notification for UI testing purposes if not connected
        if (!this.ws || !this.ws.isConnected) {
            this.renderNotification({
                type: 'doc_set_SIMULATION',
                collection: collection,
                key: 'simulated-key-' + Date.now(),
                caller: 'me'
            });
        }
    }
}

// Initialize
window.app = new DemoApp();
</script>

</body>
</html>
